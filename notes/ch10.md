# 第十章 泛型算法

## 泛型算法

- 因为它们实现共同的操作，所以称之为“**算法**”；而“**泛型**”、指的是它们可以操作在多种容器类型上。
- 泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。
- 头文件： `#include <algorithm>`或者 `#include <numeric>`(算数相关)
- 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。
- 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。

### find

- `vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);`
- 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。

## 初识泛型算法

- 标准库提供了超过100个算法，但这些算法有一致的结构。
- 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

### 只读算法

- 只读取范围中的元素，不改变元素。
- 如 `find`和 `accumulate`（在`numeric`中定义，求和）。
- `find_first_of`，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的`end`迭代器。
- 通常最好使用`cbegin`和`cend`。
- `equal`：确定两个序列是否保存相同的值。

### 写容器元素的算法

- 一些算法将新值赋予序列中的元素。
- 算法不检查写操作。
- `fill`： `fill(vec.begin(), vec.end(), 0);` 将每个元素重置为0
- `fill_n`： `fill_n(vec.begin(), 10, 0);`
- 插入迭代器`back_inserter`：
  - 用来确保算法有足够的空间存储数据。
  - `#include <iterator>`
  - `back_inserter(vec)`
- 拷贝算法`copy`：
- 输入：前两个参数指定输入范围，第三个指向目标序列。
- `copy (ilst.begin(), ilst.end(), back_inserter(ivec));`
- `copy`时必须保证目标目的序列至少要包含与输入序列一样多的元素。

### 重排容器元素的算法

- 这些算法会重排容器中元素的顺序。
- `unique`：
  - 顺序会变，重复的元素被“删除”。
  - 并没有真正删除，真正删除必须使用容器操作。
- 排序算法`sort`：
  - `stable_sort`：保留相等元素的原始相对位置。
  - `stable_sort(words.begin(), words.end(), isShorter);`

## 定制操作

**另外三种迭代器**：
- `插入迭代器`：与容器绑定在一起，实现在容器中插入元素的功能。
- `iostream迭代器`：迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。
- `反向迭代器`：实现向后遍历，配合`rbegin`和`rend`。

**算法的形参模式**：
- `alg(beg, end, other parms);`
- `alg(beg, end, dest, other parms);`
- `alg(beg, end, beg2, other parms);`
- `alg(beg, end, beg2, end2, other parms);`


|  |  |
|-----|-----|
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |

- ****：
- ****：
- ****：
- ****：
- ****：
- ****：
- ****：
- ****：