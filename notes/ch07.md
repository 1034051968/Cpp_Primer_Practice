## 第七章 函数

**形参和实参**：形参是在函数的形参表中定义的，并由调用函数时传递函数的实参初始化。

**非引用形参**：
- 普通的非引用类型的参数通过复制对应的实参实现初始化，因此函数执行完不会修改实参的值。
- `指针形参`，被复制的指针只影响对指针的赋值。
- `const形参`：既可以传递const实参，也可以传递非const实参，在函数中，不能改变实参的局部副本。

**引用形参**：
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于返回额外的信息。
- 经常用const引用来避免不必要的复制。
- `void swap(int &v1, int &v2)`

**传递指向指针的引用**： `void func(int *&v1)`，从右向左理解，v1是一个引用，于指向int型对象的指针相关联。

**对于是容器类型的形参**：调用非引用的vector会复制vector的每一个元素，一般更倾向于通过船体指向容器中需要处理的元素的迭代器。

**对于数组的形参**： 
- 非引用：`void func(int*)`等价于 `void func(int[10])`，也就是说不会复制数组，而是转换为指向第一个元素的指针，且长度限制没有意义。
- 引用：传递数组的引用本身，会检查实参数组的数组大小， `void func(int (&arr)[10])`

**main函数接受命令行参数**：
- 命令行： `prog -d -o ofile`
- 代码： `int main(int argc, char *argv[])`，有 `argv[0] = "prog"; argv[1] = "-d";argv[2] = "-o";argv[3] = "ofile";`

**静态局部对象**：一个变量如果位于函数的作用域内，但生命期跨越了这个函数的多次调用，定义为static（静态的）。

**内联（inline）函数**：
- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- inline函数可以避免函数调用的开销，可以让编译器在编译时内联地展开该函数。
- inline函数应该在头文件中定义。

**类的成员函数**：
- 每个成员函数都有一个额外的，隐含的形参this。
- 形参表后面的const，改变了隐含的this形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”。

**类的构造函数**：
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`

**重载函数**：
- 出现在相同作用域的两个函数，具有相同的名字而形参表不同，称为重载函数。
- 不能仅仅基于不同的返回类型而实现重载。
- 重载函数的三个步骤：1.候选函数；2.可行函数；3.寻找最佳匹配。
- 仅当形参是引用或指针时，形参是否为const才有影响。

**指向函数的指针**： `bool (*pf)(const string &, const string &);`

