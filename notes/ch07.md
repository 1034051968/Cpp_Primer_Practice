# 第七章 类 （Class）

## 定义抽象数据类型

**类背后的基本思想**：**数据抽象和封装**

### 类成员 （Member）
- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

### 类的成员函数
- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`
- `*this`：
    - 每个成员函数都有一个额外的，隐含的形参`this`。
    - `this`总是指向当前对象，因此`this`是一个常量指针。
    - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
    - `return *this;`可以让成员函数连续调用。
    - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
    - `const`成员函数：`this`是指向const类类型的`const`指针（既不能`this`所指向的值，也不能改变`this`保存的地址）。

### 非成员函数
- 和类相关的非成员函数，定义和声明都应该在类的外部。

### 类的构造函数
- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。
- `Sales_item(): units_sold(0), revenue(0.0) { }`
- `=default`要求编译器合成默认的构造函数。(C++11)
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`

## 访问控制与封装

- **访问说明符**（access specifiers）：
    - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
    - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
    - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
    - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

### 友元
- 允许特定的**非成员函数**访问一个类的私有成员.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`
- 通常将友元声明成组地放在类定义的开始或者结尾。

### 封装的益处
- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 类的其他特性
**可变数据成员**：`mutable size_t access_ctr; `

## 类的作用域

## 构造函数再探

**static数据成员**：
- 非static数据成员存在于类类型的每个对象中。
- static数据成员独立于该类的任意对象而存在。
- 每个static数据成员是与类关联的对象，并不与该类的对象相关联。
- 不能通过构造函数初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
- 特殊的const static成员：可以在类定义体中进行初始化。

- ****：
- ****：
- ****：
- ****：
- ****：
- ****：
- ****：
- ****：